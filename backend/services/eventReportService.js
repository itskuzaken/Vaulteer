/**
 * eventReportService.js
 * 
 * Comprehensive post-event analytics report generation service.
 * Automatically generates detailed reports when events complete, including:
 * - Attendance metrics (registered, attended, absent, late, waitlisted)
 * - Demographic breakdowns (age, gender, location, role)
 * - Timing analytics (check-in patterns, early/late arrivals)
 * - Engagement metrics (points awarded, badges earned)
 * 
 * @author GitHub Copilot
 * @created January 6, 2026
 */

const { getPool } = require('../db/pool');
const { differenceInMinutes, parseISO, format } = require('date-fns');

/**
 * Age range buckets for demographic analysis
 */
const AGE_RANGES = [
  { min: 0, max: 17, label: 'Under 18' },
  { min: 18, max: 25, label: '18-25' },
  { min: 26, max: 35, label: '26-35' },
  { min: 36, max: 45, label: '36-45' },
  { min: 46, max: 55, label: '46-55' },
  { min: 56, max: 65, label: '56-65' },
  { min: 66, max: 150, label: '65+' }
];

/**
 * Get age bucket label from birth date
 * @param {Date|string} birthDate 
 * @returns {string} Age range label
 */
function getAgeBucket(birthDate) {
  if (!birthDate) return 'Unknown';
  
  const birth = birthDate instanceof Date ? birthDate : new Date(birthDate);
  if (isNaN(birth.getTime())) return 'Unknown';
  
  const today = new Date();
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  
  for (const range of AGE_RANGES) {
    if (age >= range.min && age <= range.max) {
      return range.label;
    }
  }
  return 'Unknown';
}

/**
 * Calculate percentage with 2 decimal places
 * @param {number} part 
 * @param {number} total 
 * @returns {number}
 */
function calcPercent(part, total) {
  if (!total || total === 0) return 0;
  return Number(((part / total) * 100).toFixed(2));
}

/**
 * Generate comprehensive analytics report for a completed event
 * 
 * @param {string} eventUid - Event UID
 * @param {number|null} generatedByUserId - User ID who triggered generation (null for auto)
 * @param {Object} options - Generation options
 * @param {boolean} options.isAutoGenerated - Whether this was auto-triggered on event completion
 * @returns {Promise<Object>} Generated report data
 */
async function generateEventReport(eventUid, generatedByUserId = null, options = {}) {
  const { isAutoGenerated = false } = options;
  const pool = getPool();
  const conn = await pool.getConnection();
  
  try {
    await conn.beginTransaction();
    
    // ========== 1. GET EVENT DATA ==========
    const [eventRows] = await conn.query(
      `SELECT 
        e.event_id, e.uid, e.title, e.status,
        e.start_datetime, e.end_datetime,
        e.max_participants, e.location, e.event_type,
        e.created_by_user_id
       FROM events e
       WHERE e.uid = ?
       LIMIT 1`,
      [eventUid]
    );
    
    if (!eventRows.length) {
      throw new Error(`Event not found: ${eventUid}`);
    }
    
    const event = eventRows[0];
    
    // ========== 2. GET ALL PARTICIPANTS WITH PROFILE DATA ==========
    const [participants] = await conn.query(
      `SELECT 
        ep.participant_id,
        ep.user_id,
        ep.status AS participant_status,
        ep.attendance_status,
        ep.attendance_marked_at AS checked_in_at,
        ep.registration_date AS registered_at,
        ep.cancellation_date AS cancelled_at,
        u.uid AS firebase_uid,
        up.first_name,
        up.last_name,
        up.birthdate AS birth_date,
        up.gender,
        up.city,
        r.role AS user_role
       FROM event_participants ep
       JOIN users u ON ep.user_id = u.user_id
       LEFT JOIN user_profiles up ON u.user_id = up.user_id
       LEFT JOIN roles r ON u.role_id = r.role_id
       WHERE ep.event_id = ?`,
      [event.event_id]
    );
    
    // ========== 3. CALCULATE ATTENDANCE METRICS ==========
    const registeredParticipants = participants.filter(p => 
      p.participant_status === 'registered' || p.participant_status === 'checked_in'
    );
    const waitlistedParticipants = participants.filter(p => p.participant_status === 'waitlisted');
    const cancelledParticipants = participants.filter(p => p.participant_status === 'cancelled');
    
    const presentParticipants = participants.filter(p => 
      p.attendance_status === 'present' || p.attendance_status === 'checked_in'
    );
    const absentParticipants = participants.filter(p => 
      p.attendance_status === 'absent' || p.attendance_status === 'no_show'
    );
    const lateParticipants = participants.filter(p => p.attendance_status === 'late');
    const noShowParticipants = participants.filter(p => 
      (p.participant_status === 'registered' || p.participant_status === 'checked_in') &&
      (!p.attendance_status || p.attendance_status === 'no_show' || p.attendance_status === 'absent')
    );
    
    const totalRegistered = registeredParticipants.length;
    const totalAttended = presentParticipants.length + lateParticipants.length;
    const totalWaitlisted = waitlistedParticipants.length;
    const totalCancelled = cancelledParticipants.length;
    const totalAbsent = absentParticipants.length;
    const totalNoShow = noShowParticipants.length;
    const totalLate = lateParticipants.length;
    
    const attendanceRate = calcPercent(totalAttended, totalRegistered);
    
    // ========== 4. CALCULATE TIMING METRICS ==========
    const eventStart = event.start_datetime ? new Date(event.start_datetime) : null;
    const eventEnd = event.end_datetime ? new Date(event.end_datetime) : null;
    
    const checkInTimes = participants
      .filter(p => p.checked_in_at)
      .map(p => new Date(p.checked_in_at))
      .sort((a, b) => a - b);
    
    const firstCheckinTime = checkInTimes.length > 0 ? checkInTimes[0] : null;
    const lastCheckinTime = checkInTimes.length > 0 ? checkInTimes[checkInTimes.length - 1] : null;
    
    // Calculate on-time vs late check-ins (relative to event start)
    let onTimeCheckins = 0;
    let lateCheckins = 0;
    let totalMinutesFromStart = 0;
    let validCheckinsCount = 0;
    
    if (eventStart) {
      for (const p of participants) {
        if (p.checked_in_at) {
          const checkinTime = new Date(p.checked_in_at);
          const minutesFromStart = differenceInMinutes(checkinTime, eventStart);
          
          if (minutesFromStart <= 0) {
            onTimeCheckins++;
          } else {
            lateCheckins++;
          }
          
          totalMinutesFromStart += minutesFromStart;
          validCheckinsCount++;
        }
      }
    }
    
    const avgCheckinMinutesFromStart = validCheckinsCount > 0 
      ? Number((totalMinutesFromStart / validCheckinsCount).toFixed(2))
      : null;
    
    // ========== 5. CALCULATE DEMOGRAPHIC BREAKDOWNS ==========
    // Only include registered/attended participants for demographics
    const demographicParticipants = participants.filter(p => 
      p.participant_status === 'registered' || 
      p.participant_status === 'checked_in' ||
      p.attendance_status === 'present' ||
      p.attendance_status === 'late'
    );
    
    // Age Distribution
    const ageDistribution = {};
    for (const p of demographicParticipants) {
      const bucket = getAgeBucket(p.birth_date);
      ageDistribution[bucket] = (ageDistribution[bucket] || 0) + 1;
    }
    
    // Gender Distribution
    const genderDistribution = {};
    for (const p of demographicParticipants) {
      const gender = p.gender ? p.gender.charAt(0).toUpperCase() + p.gender.slice(1).toLowerCase() : 'Unknown';
      genderDistribution[gender] = (genderDistribution[gender] || 0) + 1;
    }
    
    // Location Distribution (City only, no province in schema)
    const locationDistribution = {};
    for (const p of demographicParticipants) {
      const location = p.city || 'Unknown';
      locationDistribution[location] = (locationDistribution[location] || 0) + 1;
    }
    
    // Role Distribution
    const roleDistribution = {};
    for (const p of demographicParticipants) {
      const role = p.user_role ? p.user_role.charAt(0).toUpperCase() + p.user_role.slice(1).toLowerCase() : 'Volunteer';
      roleDistribution[role] = (roleDistribution[role] || 0) + 1;
    }
    
    // ========== 6. CALCULATE ENGAGEMENT METRICS ==========
    // Get gamification points awarded for this event
    const [pointsResult] = await conn.query(
      `SELECT COALESCE(SUM(points_delta), 0) as total_points
       FROM gamification_events
       WHERE event_id = ? AND points_delta > 0`,
      [event.event_id]
    );
    const totalPointsAwarded = pointsResult[0]?.total_points || 0;
    
    // Get badges earned from this event (from user_achievements table)
    const [badgesResult] = await conn.query(
      `SELECT COUNT(DISTINCT ua.user_id) as badge_count
       FROM user_achievements ua
       JOIN gamification_events ge ON ge.user_id = ua.user_id AND ge.event_id = ?
       WHERE DATE(ua.earned_date) = DATE(NOW())`,
      [event.event_id]
    );
    const badgesEarnedCount = badgesResult[0]?.badge_count || 0;
    
    // Get feedback count and average rating (if feedback table exists)
    let feedbackCount = 0;
    let avgRating = null;
    
    try {
      const [feedbackResult] = await conn.query(
        `SELECT 
          COUNT(*) as feedback_count,
          AVG(rating) as avg_rating
         FROM event_feedback
         WHERE event_uid = ?`,
        [eventUid]
      );
      feedbackCount = feedbackResult[0]?.feedback_count || 0;
      avgRating = feedbackResult[0]?.avg_rating 
        ? Number(feedbackResult[0].avg_rating.toFixed(2))
        : null;
    } catch (err) {
      // event_feedback table may not exist yet - that's OK
      console.log('[EventReportService] event_feedback table not found, skipping feedback metrics');
    }
    
    // ========== 7. CHECK FOR EXISTING REPORT ==========
    const [existingReport] = await conn.query(
      `SELECT report_id FROM event_reports WHERE event_id = ? LIMIT 1`,
      [event.event_id]
    );
    
    let reportId;
    
    if (existingReport.length > 0) {
      // Update existing report
      reportId = existingReport[0].report_id;
      
      await conn.query(
        `UPDATE event_reports SET
          registered_count = ?,
          present_count = ?,
          absent_count = ?,
          late_count = ?,
          waitlisted_count = ?,
          cancelled_count = ?,
          no_show_count = ?,
          attendance_pct = ?,
          event_start_datetime = ?,
          event_end_datetime = ?,
          first_checkin_time = ?,
          last_checkin_time = ?,
          on_time_checkins = ?,
          late_checkins = ?,
          avg_checkin_minutes_from_start = ?,
          age_distribution = ?,
          gender_distribution = ?,
          location_distribution = ?,
          role_distribution = ?,
          feedback_count = ?,
          avg_rating = ?,
          total_points_awarded = ?,
          badges_earned_count = ?,
          generated_by_user_id = ?,
          is_auto_generated = ?,
          report_version = 'v2.0',
          last_updated_at = NOW()
         WHERE report_id = ?`,
        [
          totalRegistered,
          totalAttended,
          totalAbsent,
          totalLate,
          totalWaitlisted,
          totalCancelled,
          totalNoShow,
          attendanceRate,
          eventStart,
          eventEnd,
          firstCheckinTime,
          lastCheckinTime,
          onTimeCheckins,
          lateCheckins,
          avgCheckinMinutesFromStart,
          JSON.stringify(ageDistribution),
          JSON.stringify(genderDistribution),
          JSON.stringify(locationDistribution),
          JSON.stringify(roleDistribution),
          feedbackCount,
          avgRating,
          totalPointsAwarded,
          badgesEarnedCount,
          generatedByUserId,
          isAutoGenerated ? 1 : 0,
          reportId
        ]
      );
      
      console.log(`[EventReportService] Updated report ${reportId} for event ${eventUid}`);
    } else {
      // Create new report
      const [insertResult] = await conn.query(
        `INSERT INTO event_reports (
          event_id, generated_by_user_id,
          registered_count, present_count, absent_count, late_count,
          waitlisted_count, cancelled_count, no_show_count,
          attendance_pct,
          event_start_datetime, event_end_datetime,
          first_checkin_time, last_checkin_time,
          on_time_checkins, late_checkins, avg_checkin_minutes_from_start,
          age_distribution, gender_distribution, location_distribution, role_distribution,
          feedback_count, avg_rating, total_points_awarded, badges_earned_count,
          is_auto_generated, report_version, generated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'v2.0', NOW())`,
        [
          event.event_id,
          generatedByUserId,
          totalRegistered,
          totalAttended,
          totalAbsent,
          totalLate,
          totalWaitlisted,
          totalCancelled,
          totalNoShow,
          attendanceRate,
          eventStart,
          eventEnd,
          firstCheckinTime,
          lastCheckinTime,
          onTimeCheckins,
          lateCheckins,
          avgCheckinMinutesFromStart,
          JSON.stringify(ageDistribution),
          JSON.stringify(genderDistribution),
          JSON.stringify(locationDistribution),
          JSON.stringify(roleDistribution),
          feedbackCount,
          avgRating,
          totalPointsAwarded,
          badgesEarnedCount,
          isAutoGenerated ? 1 : 0
        ]
      );
      
      reportId = insertResult.insertId;
      console.log(`[EventReportService] Created new report ${reportId} for event ${eventUid}`);
    }
    
    await conn.commit();
    
    // ========== 8. RETURN FORMATTED REPORT ==========
    return {
      report_id: reportId,
      event_uid: eventUid,
      event_title: event.title,
      generated_at: new Date().toISOString(),
      is_auto_generated: isAutoGenerated,
      
      attendance: {
        total_registered: totalRegistered,
        total_attended: totalAttended,
        total_waitlisted: totalWaitlisted,
        total_cancelled: totalCancelled,
        total_absent: totalAbsent,
        total_no_show: totalNoShow,
        total_late: totalLate,
        attendance_rate: attendanceRate,
        max_participants: event.max_participants
      },
      
      timing: {
        event_start: eventStart ? eventStart.toISOString() : null,
        event_end: eventEnd ? eventEnd.toISOString() : null,
        first_checkin: firstCheckinTime ? firstCheckinTime.toISOString() : null,
        last_checkin: lastCheckinTime ? lastCheckinTime.toISOString() : null,
        on_time_checkins: onTimeCheckins,
        late_checkins: lateCheckins,
        avg_minutes_from_start: avgCheckinMinutesFromStart
      },
      
      demographics: {
        age: ageDistribution,
        gender: genderDistribution,
        location: locationDistribution,
        role: roleDistribution
      },
      
      engagement: {
        feedback_count: feedbackCount,
        avg_rating: avgRating,
        total_points_awarded: totalPointsAwarded,
        badges_earned: badgesEarnedCount
      }
    };
    
  } catch (error) {
    await conn.rollback();
    console.error(`[EventReportService] Error generating report for ${eventUid}:`, error);
    throw error;
  } finally {
    conn.release();
  }
}

/**
 * Get existing report for an event
 * 
 * @param {string} eventUid - Event UID
 * @returns {Promise<Object|null>} Report data or null if not found
 */
async function getEventReport(eventUid) {
  const pool = getPool();
  
  const [rows] = await pool.query(
    `SELECT 
      r.*,
      e.uid as event_uid,
      e.title as event_title
     FROM event_reports r
     JOIN events e ON r.event_id = e.event_id
     WHERE e.uid = ?
     ORDER BY r.generated_at DESC
     LIMIT 1`,
    [eventUid]
  );
  
  if (!rows.length) {
    return null;
  }
  
  const report = rows[0];
  
  // Parse JSON fields
  const parseJSON = (val) => {
    if (!val) return {};
    if (typeof val === 'object') return val;
    try {
      return JSON.parse(val);
    } catch {
      return {};
    }
  };
  
  // Format response
  return {
    report_id: report.report_id,
    event_uid: report.event_uid,
    event_title: report.event_title,
    generated_at: report.generated_at,
    generated_by_user_id: report.generated_by_user_id,
    is_auto_generated: Boolean(report.is_auto_generated),
    report_version: report.report_version || 'v1.0',
    
    attendance: {
      total_registered: report.registered_count || 0,
      total_attended: report.present_count || 0,
      total_waitlisted: report.waitlisted_count || 0,
      total_cancelled: report.cancelled_count || 0,
      total_absent: report.absent_count || 0,
      total_no_show: report.no_show_count || 0,
      total_late: report.late_count || 0,
      attendance_rate: report.attendance_pct ? Number(report.attendance_pct) : 0
    },
    
    timing: {
      event_start: report.event_start_datetime,
      event_end: report.event_end_datetime,
      first_checkin: report.first_checkin_time,
      last_checkin: report.last_checkin_time,
      on_time_checkins: report.on_time_checkins || 0,
      late_checkins: report.late_checkins || 0,
      avg_minutes_from_start: report.avg_checkin_minutes_from_start 
        ? Number(report.avg_checkin_minutes_from_start) 
        : null
    },
    
    demographics: {
      age: parseJSON(report.age_distribution),
      gender: parseJSON(report.gender_distribution),
      location: parseJSON(report.location_distribution),
      role: parseJSON(report.role_distribution)
    },
    
    engagement: {
      feedback_count: report.feedback_count || 0,
      avg_rating: report.avg_rating ? Number(report.avg_rating) : null,
      total_points_awarded: report.total_points_awarded || 0,
      badges_earned: report.badges_earned_count || 0
    },
    
    // PDF export info
    pdf_available: Boolean(report.pdf_s3_key),
    pdf_generated_at: report.pdf_generated_at
  };
}

/**
 * Check if an event has a report
 * 
 * @param {string} eventUid - Event UID
 * @returns {Promise<boolean>}
 */
async function hasEventReport(eventUid) {
  const pool = getPool();
  
  const [rows] = await pool.query(
    `SELECT 1 FROM event_reports r
     JOIN events e ON r.event_id = e.event_id
     WHERE e.uid = ?
     LIMIT 1`,
    [eventUid]
  );
  
  return rows.length > 0;
}

/**
 * Delete report for an event
 * 
 * @param {string} eventUid - Event UID
 * @returns {Promise<boolean>} Success status
 */
async function deleteEventReport(eventUid) {
  const pool = getPool();
  
  const [result] = await pool.query(
    `DELETE r FROM event_reports r
     JOIN events e ON r.event_id = e.event_id
     WHERE e.uid = ?`,
    [eventUid]
  );
  
  return result.affectedRows > 0;
}

/**
 * Update PDF info on a report
 * 
 * @param {string} eventUid - Event UID
 * @param {string} pdfS3Key - S3 key for the PDF
 * @returns {Promise<void>}
 */
async function updateReportPdfInfo(eventUid, pdfS3Key) {
  const pool = getPool();
  
  await pool.query(
    `UPDATE event_reports r
     JOIN events e ON r.event_id = e.event_id
     SET r.pdf_s3_key = ?, r.pdf_generated_at = NOW()
     WHERE e.uid = ?`,
    [pdfS3Key, eventUid]
  );
}

/**
 * Get summary report for event creator (limited data)
 * 
 * @param {string} eventUid - Event UID
 * @returns {Promise<Object|null>} Limited report data
 */
async function getEventReportSummary(eventUid) {
  const report = await getEventReport(eventUid);
  if (!report) return null;
  
  // Return only non-sensitive summary data
  return {
    report_id: report.report_id,
    event_uid: report.event_uid,
    event_title: report.event_title,
    generated_at: report.generated_at,
    
    attendance: {
      total_registered: report.attendance.total_registered,
      total_attended: report.attendance.total_attended,
      attendance_rate: report.attendance.attendance_rate
    },
    
    timing: {
      event_start: report.timing.event_start,
      event_end: report.timing.event_end,
      on_time_checkins: report.timing.on_time_checkins,
      late_checkins: report.timing.late_checkins
    },
    
    engagement: {
      total_points_awarded: report.engagement.total_points_awarded,
      badges_earned: report.engagement.badges_earned
    }
  };
}

module.exports = {
  generateEventReport,
  getEventReport,
  getEventReportSummary,
  hasEventReport,
  deleteEventReport,
  updateReportPdfInfo
};
